---
slug: useSyncExternalStore-the-underrated-react-api
title: useSyncExternalStore - The underrated React API
authors: [slorber]
date: 2022-09-06
twitterThreadUrl: "https://slo.im/t/articles/useSyncExternalStore"
image: ./social-card.png
---

# useSyncExternalStore - L'API React sous-estim√©e

Vous avez peut-√™tre entendu parler de [`useSyncExternalStore()`](https://reactjs.org/docs/hooks-reference.html#usesyncexternalstore), un nouveau hook de React 18 pour **souscrire √† des sources de donn√©es externes**. Il est souvent utilis√© en interne par des biblioth√®ques de gestion d'√©tat - comme [Redux](https://github.com/reduxjs/react-redux/pull/1808) - pour impl√©menter un **syst√®me de s√©lecteur**.

Mais qu'en est-il d'utiliser `useSyncExternalStore()` dans votre propre code d'application ?

Dans cet article interactif, je souhaite vous pr√©senter un probl√®me : **les hooks React qui retournent trop de donn√©es d√©clenchent des re-rendus inutiles**. Nous verrons comment `useSyncExternalStore()` peut √™tre une bonne solution.

![social card](./social-card.png)

<!-- truncate -->

<SubscribeFormEmbed />

import {
  App,
  AppFixed,
  ScrollApp,
} from "@site/articles/useSyncExternalStore-the-underrated-react-api/demos";

## Les hooks qui retournent trop de donn√©es

Illustrons le probl√®me avec [`useLocation()`](https://reactrouter.com/en/main/hooks/use-location) de React-Router.

Ce hook retourne un objet avec de nombreux attributs (`pathname`, `hash`, `search`...), mais vous pourriez ne pas tous les utiliser. Le simple fait d'appeler le hook d√©clenchera des re-rendus lorsque l'un de ces attributs est mis √† jour.

Consid√©rons cette application :

```tsx
function CurrentPathname() {
  const { pathname } = useLocation();
  return <div>{pathname}</div>;
}

function CurrentHash() {
  const { hash } = useLocation();
  return <div>{hash}</div>;
}

function Links() {
  return (
    <div>
      <Link to="#link1">#link1</Link>
      <Link to="#link2">#link2</Link>
      <Link to="#link3">#link3</Link>
    </div>
  );
}

function App() {
  return (
    <div>
      <CurrentPathname />
      <CurrentHash />
      <Links />
    </div>
  );
}
```

<App />

√Ä chaque clic sur un lien de hachage, le composant `CurrentPathname` se re-rendra, m√™me s'il n'utilise m√™me pas l'attribut `hash` üòÖ.

:::tip

Chaque fois qu'un hook retourne des donn√©es que vous n'affichez pas, pensez aux re-rendus React. Si vous n'y pr√™tez pas attention, un simple appel √† `useLocation()` ajout√© en haut d'un arbre React pourrait nuire aux performances de votre application.

:::

:::info

L'objectif n'est pas de critiquer React-Router, mais plut√¥t d'illustrer le probl√®me. `useLocation()` est simplement un bon candidat pragmatique pour cr√©er cet article interactif. Vos propres hooks React et d'autres biblioth√®ques tierces pourraient √©galement retourner trop de donn√©es.

:::

## `useSyncExternalStore` √† la rescousse ?

La [documentation officielle](https://reactjs.org/docs/hooks-reference.html#usesyncexternalstore) dit :

> useSyncExternalStore est un hook recommand√© pour lire et souscrire √† des sources de donn√©es externes d'une mani√®re compatible avec les fonctionnalit√©s de rendu concurrent comme l'hydratation s√©lective et le d√©coupage en tranches de temps.
> Cette m√©thode retourne la valeur du store et accepte trois arguments :
>
> - `subscribe` : fonction pour enregistrer un callback qui est appel√© √† chaque fois que le store change.
> - `getSnapshot` : fonction qui retourne la valeur actuelle du store.
> - `getServerSnapshot` : fonction qui retourne l'instantan√© utilis√© lors du rendu serveur.

```tsx
function useSyncExternalStore<Snapshot>(
  subscribe: (onStoreChange: () => void) => () => void,
  getSnapshot: () => Snapshot,
  getServerSnapshot?: () => Snapshot,
): Snapshot;
```

Cela semble un peu abstrait. Cette [page de documentation b√™ta](https://beta.reactjs.org/learn/you-might-not-need-an-effect#subscribing-to-an-external-store) donne un bon exemple :

```tsx
function subscribe(callback) {
  window.addEventListener("online", callback);
  window.addEventListener("offline", callback);
  return () => {
    window.removeEventListener("online", callback);
    window.removeEventListener("offline", callback);
  };
}

function useOnlineStatus() {
  return useSyncExternalStore(
    subscribe,
    () => navigator.onLine,
    () => true,
  );
}

function ChatIndicator() {
  const isOnline = useOnlineStatus();
  // ...
}
```

Il s'av√®re que l'historique du navigateur peut √©galement √™tre consid√©r√© comme une source de donn√©es externe. Voyons comment utiliser `useSyncExternalStore` avec React-Router !

## Impl√©mentation de `useHistorySelector()`

React-Router expose tout ce dont nous avons besoin pour connecter `useSyncExternalStore` :

- acc√©der √† l'historique du navigateur avec [`useHistory()`](https://v5.reactrouter.com/web/api/Hooks/usehistory)
- souscrire aux mises √† jour de l'historique avec [`history.listen(callback)`](https://github.com/remix-run/history/blob/main/docs/api-reference.md#history.listen)
- acc√©der √† un instantan√© de l'emplacement actuel avec [`history.location`](https://github.com/remix-run/history/blob/main/docs/api-reference.md#historylocation)

:::caution

Ce site utilise React-Router v5 : la solution sera diff√©rente pour React-Router v6 ([voir](https://twitter.com/Zh0uzi/status/1567523679604539405)).

:::

L'impl√©mentation de `useHistorySelector()` est relativement simple :

```tsx
function useHistorySelector(selector) {
  const history = useHistory();
  return useSyncExternalStore(history.listen, () =>
    selector(history),
  );
}
```

Utilisons-la dans notre application :

```tsx
function CurrentPathname() {
  const pathname = useHistorySelector(
    (history) => history.location.pathname,
  );
  return <div>{pathname}</div>;
}

function CurrentHash() {
  const hash = useHistorySelector(
    (history) => history.location.hash,
  );
  return <div>{hash}</div>;
}
```

<AppFixed />

D√©sormais, lorsque vous cliquez sur un lien de hachage ci-dessus, le composant `CurrentPathname` **ne se r√©affichera plus** !

## Autre exemple : `scrollY`

Il existe tant de sources de donn√©es externes auxquelles s'abonner, et impl√©menter votre propre syst√®me de s√©lecteurs par-dessus pourrait vous permettre d'optimiser les r√©affichages React.

Par exemple, supposons que nous voulions utiliser la position `scrollY` d'une page. Nous pouvons impl√©menter ce hook React personnalis√© :

```tsx
// A memoized constant fn prevents unsubscribe/resubscribe
// In practice it is not a big deal
function subscribe(onStoreChange) {
  global.window?.addEventListener("scroll", onStoreChange);
  return () =>
    global.window?.removeEventListener(
      "scroll",
      onStoreChange,
    );
}

function useScrollY(selector = (id) => id) {
  return useSyncExternalStore(
    subscribe,
    () => selector(global.window?.scrollY),
    () => undefined,
  );
}
```

Nous pouvons d√©sormais utiliser ce hook avec un s√©lecteur optionnel :

```tsx
function ScrollY() {
  const scrollY = useScrollY();
  return <div>{scrollY}</div>;
}

function ScrollYFloored() {
  const to = 100;
  const scrollYFloored = useScrollY((y) =>
    y ? Math.floor(y / to) * to : undefined,
  );
  return <div>{scrollYFloored}</div>;
}
```

<ScrollApp />

Faites d√©filer la page et observez comment les composants ci-dessus se r√©affichent ? L'un se r√©affiche moins que l'autre !

:::info

Lorsque vous n'avez pas besoin d'une pr√©cision au pixel pr√®s pour `scrollY`, renvoyer une valeur √† large plage comme `scrollY` peut aussi √™tre consid√©r√© comme un retour excessif. Envisagez de renvoyer une valeur plus restreinte.

Par exemple : un hook `useResponsiveBreakpoint()` qui ne renvoie qu'un ensemble limit√© de valeurs (`small`, `medium` ou `large`) sera plus optimis√© qu'un hook `useViewportWidth()`.

Si un composant React ne g√®re diff√©remment que les √©crans `large`, vous pouvez cr√©er un hook encore plus cibl√© `useIsLargeScreen()` renvoyant un bool√©en.

:::

## Conclusion

J'esp√®re que cet article vous a convaincu de reconsid√©rer `useSyncExternalStore()`. Je trouve que ce hook est actuellement sous-utilis√© dans l'√©cosyst√®me React et m√©rite davantage d'attention. Il existe de nombreuses sources de donn√©es externes auxquelles vous pouvez vous abonner.

Si vous n'avez pas encore migr√© vers React 18, il existe un shim npm [use-sync-external-store](https://www.npmjs.com/package/use-sync-external-store) que vous pouvez d√©j√† utiliser dans les anciennes versions. Il existe √©galement une exportation `use-sync-external-store/with-selector` au cas o√π vous auriez besoin de renvoyer une valeur m√©mo√Øs√©e non primitive.